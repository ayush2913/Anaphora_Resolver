Anaphora Resolver
=================

Introduction
------------
This project is aimed at building an **Anaphora Resolver** for the Hindi 
Language. This is a part of a challenge faced in the field of Natural Language 
Processing. Anaphora is an expression that refers to another expression
(Antecedent) that has occured previously.

	Example
	Ram saw a laptop yesterday. He wants to buy it.
	
In the above example we have 2 anaphoras, *He* and *it*. Now, with our world 
knowledge we already know that *He* refers to *Ram* and similarly, *it* 
refers to *laptop*. To resolve such relations in a large text corpus (Hindi)
is called Anaphora Resolution

An anaphora in Hindi can be divided into 3 types (though not a stict
categorization).

1. Entity type anaphora (eg. usne, use, mein, vah, etc) which always refers to 
   an entity type word group such as Person, Organizations, Places, etc.
2. Event type anaphora (eg. yeh, iske baad, isliye, etc), which always refer to
   an event which are verbs in this case.
3. Unknown types (eg. sabhi, kabhi, etc)

Project Segments
---------------- 
This project is being completed in a number of segments.

1. Anaphora Classifier: To classify a giveb anaphora into the above three
   categories
2. Event Anaphora Resolver: To resolve the relations between the event anaphora
   and its antecedent, and also identify the modifiers of the antecendent.
3. Entity Anaphora Resolver: To resolve the relations between the entity 
   anaphora and its antecedent, then therby also indentifying its modifier
   to complete the span of the antecedent.

Tools built for Hindi language specific procedural programming
--------------------------------------------------------------

## SSF extraction tool

This tool has been developed to extract relavent data from the (visually
confusing!) SSF data files.

An SSF file contains all the morphological data pertaining to the words used
in the corpus, the dependency relations between the word groups used in the 
courpus and other relavent information such as name entity tags, reference to
the anaphoras (manually marked for developing the training data, etc).

So, each line can convey either one of the four informations:

1. Details of the file, such as the source and authur of the file
2. Indicator to the start or end of the sentence.
3. Features corresponding to the word groups (also called chunks)
4. Features corresponding to the words contained in the word groups

In preparing the training data for a learning algorithm, it is often
required to extract the features related to the word group and the 
words contained in the group (chunk). Hence this tool can be used to
extract such data easily by using few simple lines of codes:

1. Make an object of the class SSFextract to call all the functions
   associated with the class
	
	`SSFextract data = new SSFextract("SSF line");`

Now, this object will take an argument which is the line from which the data has
to be extracted.

2. Now, appropriate features can be extracted using this object, `data`.

	`String headChunkID = data.headChunkID;`   

## Visualizing Dependency Tree tool

This tool can be used to analyze the dependency relations existing between
the word groups. These relations are generated by using the core parser 
component of the parser developed for the Paninian formalism. This tool 
can be helpful for researchers, trying to find out some important relation
between word groups.

This tool returns a JFrame with all the visual data.

Using this tool:

1. Make an object of the class DependencyTree and as an argument to it, pass the 
   path of the directory that contains the files for which the trees has to be 
   generated.

   	`DependencyTree trees = new DependencyTree("path to the directory");`

2. Now call the method: openFiles() to display all the dependency data.

	`openFiles();`

## Generation of raw data from SSF data

This tool can be used to get the raw text files containing only the Hindi words
from a SSF file. This can be used to for the analysis of inter-sentential
relations by the researchers.

It gives text files that also contains the word grouping information.

Using the tool:

1. Make an object of the class GenerateTextFiles and pass the paths to the input
   directory (containing the SSF files) and the path to the output directory (in
   which the raw text files has to be stored)

   	`GenerateTextFiles gen = new GenerateTextFiles("input directory
			path","output directory path");`

2. Now call the method openFolder() to extract all SSF files and get the raw
   Hindi data in separate folder

  	`gen.openFolder();`

Components of the Anaphora Resolver
-----------------------------------

## Anaphora Classifier

These classes can be used for the complete testing and model building using the
training data. This component consists of 3 classes, each designed for specfic
purpose.

1. **AnaphoraClassifierArff**

Make an object of the class and pass the path to the training file
folder and then call the following functions in series.
(Note that this component is still in the development phase and we will try to
remove such function callings in the final module)

	AnaphoraClassifierArff train = new AnaphoraClassifierArff("Path to the
			training directory");
	train.designstructureOfArff();
	train.designFormat();
	train.getFileList();
	train.getFileContent();

2. **BuildingClassifierModel**

Make an object of this class and pass the training file (.arff) to the function
called after the object initialization

	BuildingClassifierModel model = new BuildingClassifierModel();
	model.train("path to the training file (.arff)");

3. **TestClassifier**

Make an object of this class and pass the path to the directory containing the
test files and then call a number of functions in series.
(Note that this component is still in the development phase and we will try to
remove such function callings in the final module)

	TestClassifier test = new TestClassifier("Path to the directory
			containing the test files");
	test.readModel();
	test.getFileList();
	test.getFileContent();
	test.displayResults();

Hence, the results of the classifer will be displayed in the end.
